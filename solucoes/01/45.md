## Problema


45 - Considera a seguinte classe:

```cs
public abstract class NPC
{
    public float HP { get; protected set; }

    public NPC(float hp)
    {
        HP = hp;
    }

    public void PlayTurn()
    {
        if (FindEnemies())
        {
            AttackEnemies();
        }
        if (FindFood())
        {
            EatFood();
        }
        Move();
    }

    protected abstract bool FindFood();
    protected abstract bool FindEnemies();
    protected abstract void EatFood();
    protected abstract void AttackEnemies();

    protected virtual void Move()
    {
        Console.WriteLine(this.GetType() + " has moved!");
    }
}
```

Responde às seguintes questões:

1. É possível instanciar esta classe? Porquê?
2. É possível estender esta classe? Porquê?
3. Que métodos desta classe podem ser sobrepostos (_overridden_)? Porquê?
4. Que métodos desta classe **não** podem ser sobrepostos (_overridden_)?
   Porquê?
5. Cria pelo menos 3 subclasses concretas (não abstratas), representando
   diferentes NPCs num jogo, com lógicas concretas e específicas para cada um
   deles. Os métodos `EatFood()` e `AttackEnemies()` podem consistir apenas de
   `Console.WriteLines`.
6. Cria uma classe `Program` com um método `Main()` para testar as classes
   criadas no ponto anterior. Por exemplo, criar uma ou mais instâncias de cada
   classe, colocar as mesmas numa coleção de `NPC`, percorrer a coleção, e
   invocar o método `PlayTurn()` em cada uma delas. Repara que, além do
   construtor, só o método `PlayTurn()` pode ser invocado a partir de outras
   classes.
7. Identifica a presença de polimorfismo na solução que apresentaste no ponto
   anterior.
8. Desenha o diagrama UML da solução apresentada.




## Soluções



### Solução 1

1. Não porque a classe é abstract ou seja, é vazia, os seus métodos e
propriedades não têem corpo.

2. Podem e convêm estender senão não serve de nada.
Classes abstract ou virtual podem ser extendidas.
Logicamente um NPC é algo mais generalizado e global por isso é lógico
que a classe NPC seja algo sem corpo (só com as "regras" e requisitos mínimos)
e depois as classes que extendam sejam os variados tipos de NPC (warrior, 
mage, etc).

3. Os métodos `FindFood()`, `FindEnemies()`, `EatFood()` e `AttackEnemies()`
podem e devem ser extendidos porque são abstract (ou seja não têem corpo)
e o `Move()` pode também porque é virtual (mas não tem de ser).

4. O método `PlayTurn()` não pode ser sobreposto porque não contêm nem virtual
e nem abstract.

5.
Classe Warrior:
```csharp
using System;

namespace NPCS
{
    public class Warrior : NPC
    {
        // Variável de vida. O new oculta a herança original.
        public new float HP { get; set; }
        // Variável que gera números aleatórios.
        private Random _random = new Random();

        // Construtor que define a vida
        public Warrior(float hp) : base(hp) {
            HP = hp;
        }

        /* Método que decide de forma aleatória se o Warrior
         * encontra ou não comida.
         * Funciona por cima da herança original através do override. */
        protected override bool FindFood() {
            int randominput = _random.Next(1, 2);
            if (randominput == 1) {
                return true;
            } else {
                return false;
            }
        }

         /* Método que decide de forma aleatória se o Warrior
          * encontra ou não inimigos.
          * Funciona por cima da herança original através do override. */
        protected override bool FindEnemies() {
            int randominput = _random.Next(1, 2);
            if (randominput == 1) {
                return true;
            } else {
                return false;
            }
        }

        /* Método que escreve no ecrã que o Warrior está a comer.
         * Funciona por cima da herança original através do override. */
        protected override void EatFood() {
            Console.WriteLine("Warrior eats food");
        }

        /* Método que escreve no ecrã que o Warrior está a atacar os inimigos.
         * Funciona por cima da herança original através do override. */
        protected override void AttackEnemies() {
            Console.WriteLine("Mage attack enemies");
        }
    }
}

```
Classe Mage: 
```csharp
using System;

namespace NPCS
{
    public class Mage : NPC
    {
        // Variável de vida. O new oculta a herança original.
        public new float HP { get; set; }
        // Variável que gera números aleatórios.
        private Random _random = new Random();

        // Construtor que define a vida
        public Mage(float hp) : base(hp) {
            HP = hp;
        }

        /* Método que decide de forma aleatória se o Mage
         * encontra ou não comida.
         * Funciona por cima da herança original através do override. */
        protected override bool FindFood() {
            int randominput = _random.Next(1, 2);
            if (randominput == 1) {
                return true;
            } else {
                return false;
            }
        }

        /* Método que decide de forma aleatória se o Mage
         * encontra ou não inimigos.
         * Funciona por cima da herança original através do override. */
        protected override bool FindEnemies() {
            int randominput = _random.Next(1, 2);
            if (randominput == 1) {
                return true;
            } else {
                return false;
            }
        }

        /* Método que escreve no ecrã que o Mage está a comer.
         * Funciona por cima da herança original através do override. */
        protected override void EatFood() {
            Console.WriteLine("Mage eats food");
        }

        /* Método que escreve no ecrã que o Mage está a atacar os inimigos.
         * Funciona por cima da herança original através do override. */
        protected override void AttackEnemies() {
            Console.WriteLine("Mage attacks enemies");
        }
    }
}

```
Classe Rogue:
```csharp
using System;

namespace NPCS
{
    public class Rogue : NPC
    {
        // Variável de vida. O new oculta a herança original.
        public new float HP { get; set; }
        // Variável que gera números aleatórios.
        private Random _random = new Random();

        // Construtor que define a vida
        public Rogue(float hp) : base(hp) {
            HP = hp;
        }

        /* Método que decide de forma aleatória se o Rogue
         * encontra ou não comida.
         * Funciona por cima da herança original através do override.*/
        protected override bool FindFood() {
            int randominput = _random.Next(1, 2);
            if (randominput == 1) {
                return true;
            } else {
                return false;
            }
        }

        /* Método que decide de forma aleatória se o Rogue
         * encontra ou não inimigos.
         * Funciona por cima da herança original através do override.*/
        protected override bool FindEnemies() {
            int randominput = _random.Next(1, 2);
            if(randominput == 1) {
                return true;
            } else {
                return false;
            }
        }

        /* Método que escreve no ecrã que o Rogue está a comer.
         * Funciona por cima da herança original através do override. */
        protected override void EatFood() {
            Console.WriteLine("Rogue eats food");
        }

        /* Método que escreve no ecrã que o Rogue está a atacar os inimigos.
         * Funciona por cima da herança original através do override. */
        protected override void AttackEnemies() {
            Console.WriteLine("Rogue attacks enemies");
        }
    }
}

```

6. 

Classe Program:

```csharp
using System;
using System.Collections;
using System.Collections.Generic;

namespace NPCS
{
    class Program
    {
        // Lista de subclasses de NPC.
        private static List<NPC> classlist = new List<NPC>();

        static void Main(string[] args) {
            // Adicionar as subclasses e as respetivas vidas no construtor.
            classlist.Add(new Warrior(hp: 10f));
            classlist.Add(new Mage(hp: 3f));
            classlist.Add(new Rogue(hp: 5f));

            // Chamar o método PlayTurn de todas as subclasses.
            foreach(NPC item in classlist) {
                item.PlayTurn();
            }
        }
    }
}
```

7. Os métodos `FindFood()`, `FindEnemies()`, `EatFood()` e `Attack Enemies()`
nas subclasses estão a sobrepor (override) aos métodos originais na classe NPC.
As variáveis HP estão a usar o new ou seja, estão a ocultar a variável original
em vez de sobrepor.

8. 

![image](images/FranciscoPires_ex01_45_uml.jpg)


*Por [Francisco Pires](https://github.com/FRP7)*