## Problema

2 - Considera o seguinte código inicial para um jogo de _real-time strategy_
(RTS):

```cs
public struct Vector2
{
    public float X { get; }
    public float Y { get; }

    public Vector2(float x, float y)
    {
        X = x;
        Y = y;
    }
}
```

```cs
public interface IUnit
{
    string UnitName { get; }
    Vector2 Position { get; }
    float Health { get; }

    void Move(Vector2 newPosition);
}
```

```cs
public class Unit : IUnit
{
    public string UnitName { get; private set; }
    public Vector2 Position { get; private set; }
    public float Health { get; private set; }

    public Unit(string name, Vector2 position, float health)
    {
        UnitName = name;
        Position = position;
        Health = health;
    }

    public void Move(Vector2 newPosition)
    {
        Position = newPosition;
    }

    public override string ToString()
    {
        return $"{UnitName} at ({Position.X:f1}, {Position.Y:f1}) " +
            $"with {Health:f1} HP";
    }
}
```

Chegaste a um ponto no desenvolvimento do teu jogo em que pretendes ter
batalhões ou grupos de unidades que funcionem de forma semelhante às unidades
individuais, nomeadamente que implementem a interface `IUnit`. Queres ainda
permitir a existência de sub-batalhões, ou seja, sub-grupos dentro dos grupos
de unidades. O funcionamento das propriedades e dos métodos de um grupo de
unidades deve ser o seguinte:

* `Name` - Um grupo de unidades deve ter o nome `Group of x units`, em que `x`
  representa o número de unidades no grupo (incluíndo unidades em
  sub-grupos).
* `Position` - Deve representar o
  [centroide](https://math.stackexchange.com/questions/1801867/finding-the-centre-of-an-abritary-set-of-points-in-two-dimensions)
  (média da posição _x_ e média da posição _y_) das posições das unidades no
  grupo. A posição de um sub-grupo deve contar apenas como uma unidade.
* `Health` - Média da `Health` das unidades individuais. A `Health` de um
  sub-grupo deve contar apenas como uma unidade.
* `Move()` - A posição dada é o novo centroide do grupo. Todas as unidades
  individuais devem manter as posições relativas entre si. Para o efeito deve
  ser determinado o vetor de movimento entre os dois centroides
  (`= newPos - oldPos`), e este vector deve ser adicionado à posição atual de
  cada unidade no grupo, como ilustrado na seguinte imagem:

![image](002/002.png)

_Autoria dos ícones na imagem: [Eucalyp](https://www.flaticon.com/authors/eucalyp)
[(Flaticon)](https://www.flaticon.com/)_

1. Qual o _design pattern_ ideal para resolveres este problema?
2. Aplica e adapta o _design pattern_ em questão para resolveres o problema,
   minimizando dentro do possível alterações ao código existente. Nota que os
   _design patterns_ apenas oferecem soluções gerais, pelo que não tens de
   seguir exatamente o respetivo _template_, sobretudo se isso fizer sentido e
   melhorar a tua solução final.
3. Cria uma classe `Program` com o método `Main()` para testares a solução
   desenvolvida em modo consola e sem interação com o utilizador.

## Soluções

## Solução 1


1. O _design pattern_ ideal para resolver este problema é o _composite pattern_.

2. Class Battalion:

```cs
using System.Collections.Generic;

namespace Ex2_02
{
    class Battalion : List<IUnit>, IUnit
    {
        // Returns the name of the Battalion based on the number of Units
        public string UnitName => string.Format($"Group of {this.Count} units");

        // Returns a `Vector2` with the center position of the Battalion
        public Vector2 Position { 
            get {
                // Initialize a new `x` & `y` to save the sum of all units positions
                float x = 0, y = 0;

                // Loops through all the units in the Battalion
                foreach(IUnit u in this)
                {
                    // Sum the X position of the current Unit `u` to `x`
                    x += u.Position.X;
                    // Sum the Y position of the current Unit `u` to `y`
                    y += u.Position.Y;
                }

                // Return the average for the x and y values as a `Vector2`
                return new Vector2(x / this.Count, y / this.Count);
            }
        }

        // Returns the average health of the Battalion
        public float Health {
            get {
                // Initialize a new float to save the total ammout of hp in the Battalion
                float hp = 0;

                // Loop through all the units in the battalion
                foreach (IUnit u in this)
                {
                    // Sums the Unit's `u` hp to the `hp` counter
                    hp += u.Health;
                }

                // Returns the average hp of the Battalion
                return hp / this.Count;
            }
        }

        // Constructor that calls the base class `List<IUnit>`
        public Battalion() : base() { }

        public void Move(Vector2 newPosition)
        {
            // Get the movement vector by subtraction newPosition with the current postion
            Vector2 movement = new Vector2(newPosition.X - Position.X, newPosition.Y - Position.Y);

            // Loop through all the units in the battalion
            foreach(IUnit u in this)
            {
                // Move all of them acording to the movement vector we got before
                u.Move(new Vector2(u.Position.X + movement.X, u.Position.Y + movement.Y));
            }
        }
    }
}
```

**Nota do docente:** em breve vamos falar de um princípio que diz o seguinte:

_Favour composition over inheritance_

Resumindo, o princípio diz para preferirmos usar composição em vez de herança, sempre
que possível. Neste caso a classe `Battalion` devia ter uma lista como variável de
instância, e não herdar de lista. Por exemplo, se futuramente quisermos ter uma classe
intermédia `AbstractUnit`, que implementa `IUnit`, com alguma funcionalidade comum
entre `Unit` e `Battalion`. Neste caso já não iria funcionar, pois a classe `Battalion`
já estende `List<T>`, e no C# não existe herança múltipla.

3. Class Program:

```cs
using System;

namespace Ex2_02
{
    class Program
    {
        static void Main(string[] args)
        {
            // Creates 3 new Units
            Unit unit1 = new Unit("Soldier", new Vector2(5, 10), 100);
            Unit unit2 = new Unit("Cannon", new Vector2(10, 20), 500);
            Unit unit3 = new Unit("Sniper", new Vector2(20, 30), 70);

            // Create a new Battalion
            Battalion battalion = new Battalion {
                unit1,
                unit2,
                unit3
            };

            // Print the current position of the battalion
            Console.WriteLine($"Battalion {battalion.UnitName} is at({ battalion.Position.X:f1}, " +
                $"{ battalion.Position.Y:f1}) with {battalion.Health:f1} HP");
            Console.WriteLine("--Units--");
            // Print the current position of each unit on the battalion
            foreach (IUnit unit in battalion)
            {
                Console.WriteLine(unit.ToString());
            }

            // Move the battalion to a new position
            battalion.Move(new Vector2(35.7f, 23));


            // Print the new position of the battalion
            Console.WriteLine($"Battalion {battalion.UnitName} is at({ battalion.Position.X:f1}, " +
                $"{ battalion.Position.Y:f1}) with {battalion.Health:f1} HP");
            Console.WriteLine("--Units--");
            // Print the new position of each unit on the battalion
            foreach (IUnit unit in battalion)
            {
                Console.WriteLine(unit.ToString());
            }
        }
    }
}

```

*Por [Leandro Brás](https://github.com/xShadoWalkeR)*

### Solução 2

1. O _design pattern_ ideal para resolver este problema será o 
   _Composite Pattern_.

2. Aplicação do _Composite Pattern_ com a classe `Squad`:

```cs
using System;
using System.Collections.Generic;

public class Squad : IUnit
{
    // Variável privada de classe do tipo ICollection<IUnit>, na qual podem ser
    // guardados vários tipos de coleções que permitam usar funcionalidades
    // necessárias
    private ICollection<IUnit> untCol;

    // Propriedade pública read-only do tipo IEnumerable<IUnit>que permite
    // a código externo aceder à informação de untCol do Squad, mas
    // não alterá-la
    public IEnumerable<IUnit> UntCol => untCol;

    // Propriedade pública read-only, que permite a código externo aceder
    // ao nome do Squad, mas não alterá-lo
    public string UnitName => $"Group of {untCol.Count} units";

    // Propriedade pública read-only, que permite a código externo aceder
    // à posição do Squad, mas não alterá-la
    public Vector2 Position
    {
        // Getter que, usando duas variáveis locais, calcula a média das
        // posições (X e Y) de todas as IUnit no Squad e devolve a mesma
        get
        {
            float xCalc = 0;
            float yCalc = 0;
            foreach (IUnit u in untCol) xCalc += u.Position.X;
            foreach (IUnit u in untCol) yCalc += u.Position.Y;
            return new Vector2(xCalc / untCol.Count, yCalc / untCol.Count);
        }
    }

    // Propriedade pública read-only, que permite a código externo aceder
    // à vida do Squad, mas não alterá-la
    public float Health
    {
        get
        {
            float totalHealth = 0;
            foreach (IUnit u in untCol) totalHealth += u.Health;
            return totalHealth / untCol.Count;
        }
    }

    // Método público que permite a código externo adicionar uma IUnit a
    // untCol
    public void AddUnit(IUnit u)
    {
        if(u != null)
        {
            untCol.Add(u);
        }
    }

    // Método público que permite a código externo remover uma IUnit de
    // untCol
    public void RemoveUnit(IUnit u)
    {
        untCol.Remove(u);
    }

    // Método público, que permite a código externo alterar a posição
    // do Squad, e subsequentemente dos seus elementos
    // Para este efeito, cria uma variável local do tipo Vector2, na qual
    // guarda o vetor do movimento, calculado ao subtrair X e Y da posição
    // atual do X e Y da posição alvo, chamando após isto o método Move()
    // dos vários elementos IUnit do Squad num ciclo foreach, dando ao
    // mesmo como parâmetro um novo Vector2 cujos valores para X e Y
    // resultam de um cálculo de adição do X e Y do vetor de movimento ao
    // X e Y da posição atual do IUnit em questão em dada iteração dociclo
    public void Move(Vector2 targetPos)
    {
        Vector2 movVec = new Vector2(targetPos.X - Position.X,
            targetPos.Y - Position.Y);
        foreach (IUnit u in untCol)
            u.Move(new Vector2(u.Position.X + movVec.X, 
                u.Position.Y + movVec.Y));
    }

    // Construtor do Squad, no qual a variável untCol, do tipo
    // ICollection<IUnit> é inicializada, guardando uma lista List<IUnit>
    // na mesma e guardando na mesma o IEnumerable dado como parâmetro
    public Squad(IEnumerable<IUnit> units)
    {
        untCol = new List<IUnit>(units);
    }

    // Método ToString(), que devolve uma string com uma descrição curta
    // do Squad
    public override string ToString() => $"{UnitName} at ({Position.X:f1}" +
        $", {Position.Y:f1}) with {Health:f1} HP";
}
```

3. Classe `Program`:

```cs
using System;
using System.Collection.Generic;

class Program
{
    static void Main(string[] args)
    {
        // Criar variável do tipo IEnumerable<IUnit> e testar guardar uma
        // lista na mesma
        IEnumerable<IUnit> unitBundle1 = new List<IUnit>()
        {
            new Unit("Lancer", new Vector2(1f, 1f), 100f),
            new Unit("Assassin", new Vector2(1f, 2f), 80f),
            new Unit("Caster", new Vector2(1f, 3f), 90f)
        };

        // Criar variável do tipo Squad, guardando na mesma os conteúdos
        // da variável unitBundle1
        Squad squad1 = new Squad(unitBundle1);

        // Criar variável do tipo IEnumerable<IUnit> e testar guardar um
        // hashset na mesma
        IEnumerable<IUnit> unitBundle2 = new HashSet<IUnit>()
        {
            new Unit("Saber", new Vector2(2f, 1f), 150f),
            new Unit("Ruler", new Vector2(2f, 2f), 200f),
            new Unit("Rider", new Vector2(2f, 3f), 140f),
            new Unit("Archer", new Vector2(2f, 4f), 110f),
            new Unit("Berserker", new Vector2(2f, 5f), 170f)
        };

        // Criar variável do tipo Squad, guardando na mesma os conteúdos
        // da variável unitBundle2
        Squad squad2 = new Squad(unitBundle2);

        // Testar a adição de unidades a squad2, após a sua criação,
        // através do método próprio para o mesmo
        squad2.AddUnit(squad1);

        // Percorrer ambos squads, imprimindo o ToString() de cada IUnit
        // contida nos mesmos (variáveis de tipo Squad contidas noutra
        // variável de tipo Squad são tratadas como IUnit também)
        Console.WriteLine("1st Squad's Units:");
        foreach(IUnit u in squad1.UntCol) Console.WriteLine(u);
        Console.WriteLine("\n2nd Squad's Units:");
        foreach(IUnit u in squad2.UntCol) Console.WriteLine(u);

        // Imprimir os ToString() de ambos Squads
        Console.WriteLine("\n1st Squad's description:");
        Console.WriteLine(squad1);
        Console.WriteLine("\n2nd Squad's description:");
        Console.WriteLine(squad2);

        // Chamar método Move() de ambos Squads, dando-lhes o mesmo vetor,
        // para motivos de teste
        Console.WriteLine("\nMoving both squads' units...\n");
        squad1.Move(new Vector2(5f, 5f));
        squad2.Move(new Vector2(5f, 5f));

        // Percorrer ambos squads, imprimindo o ToString() de cada IUnit
        // contida nos mesmos
        Console.WriteLine("1st Squad's Units after move:");
        foreach (IUnit u in squad1.UntCol) Console.WriteLine(u);
        Console.WriteLine("\n2nd Squad's Units after move:");
        foreach (IUnit u in squad2.UntCol) Console.WriteLine(u);
    }
}
```

**Nota:** Código de teste para este exercício encontra-se neste
[repositório](https://github.com/PmaiWoW/LP2_Github_Exercises).

*Por [Pedro Inácio](https://github.com/PmaiWoW).*


### Solução 3

1. O _design pattern_ ideal para resolver este problema será o 
   _Composite Pattern_.

2. Aplicação do _Composite Pattern_ com a classe `Squad`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;


namespace _02_02
{
    /// <summary>
    /// Classe da Squad.
    /// </summary>
    public class Squad
    {  
        // Stack das units da squad.
        public Stack<object> squadstack = new Stack<object>();
        //

        // Variável string de leitura de exposição do número de units na squad.
        protected virtual string Name {
            get => $"Group of {squadstack.Count} units";
        }
        //

        // Variável Vector2 da posição da squad.
        protected virtual Vector2 Position {
            get {
                float sumX = 0;
                float sumY = 0;
                float avgX;
                float avgY;
                foreach (Unit item in squadstack) {
                    sumX += item.Position.X;
                }
                foreach (Unit item in squadstack) {
                    sumY += item.Position.Y;
                }
                avgX = sumX / squadstack.Count;
                avgY = sumY / squadstack.Count;

                return new Vector2(avgX, avgY);
            }
            set {; }
        }
        //

        // Variável float de leitura da vida da squad.
        protected virtual float Health { 
            get {
                float sum = 0;
                foreach (Unit item in squadstack) {
                    sum += item.Health;
                }
                return sum / squadstack.Count;
            }
        }
        //
       
        /// <summary>
        /// Método de adicionar movimento à squad.
        /// </summary>
        /// <param name="newposition"> Novo movimento. </param>
        public virtual void Move(Vector2 newposition) {
            Vector2 finalmovement = new Vector2(newposition.X - Position.X,
                newposition.Y - Position.Y);

            foreach (Unit item in squadstack) {
                item.Move(new Vector2(Position.X + finalmovement.X, 
                    Position.Y + finalmovement.Y));
            }
        }
        //
    }
    //
}

```

Subclasse `SubSquad`: 

```cs
using System;
using System.Collections;
using System.Collections.Generic;

namespace _02_02
{
    /// <summary>
    /// Subclasse de Squad.
    /// </summary>
    public class SubSquad : Squad
    {
        // Stack das units da subsquad.
        public Stack<object> subsquadstack = new Stack<object>();
        //

       /* Variável string de leitura de exposição do número de units na
        * subsquad.*/
        protected override string Name {
            get => $"Group of {subsquadstack.Count} units";
        }
        //

        // Variável Vector2 da posição da subsquad.
        protected override Vector2 Position {
            get {
                float sumX = 0;
                float sumY = 0;

                foreach (Unit item in subsquadstack) {
                    sumX += item.Position.X;
                }
                foreach (Unit item in subsquadstack) {
                    sumY += item.Position.Y;
                }

                return new Vector2(sumX, sumY);
            }
        }
        //

        // Variável float de leitura da vida da subsquad.
        protected override float Health {
            get {
                float sum = 0;
                foreach (Unit item in subsquadstack) {
                    sum += item.Health;
                }
                return sum;
            }
        }
        //

        /// <summary>
        /// Método de adicionar movimento à subsquad.
        /// </summary>
        /// <param name="newposition"> Novo movimento. </param>
        public override void Move(Vector2 newposition) {
            Vector2 finalmovement = new Vector2(newposition.X - Position.X,
                newposition.Y - Position.Y);

            foreach (Unit item in subsquadstack) {
                item.Move(new Vector2(Position.X + finalmovement.X,
                    Position.Y + finalmovement.Y));
            }
        }
        //
    }
    //
}

```

3. Classe `Program`:

```cs
using System;

namespace _02_02
{
    /// <summary>
    /// Classe para testar a solução.
    /// </summary>
    class Program
    {
        static void Main(string[] args) {
            // Aceder à classe Squad.
            Squad squad = new Squad();
            //
            // Aceder à subclasse SubSquad.
            SubSquad subsquad = new SubSquad();
            //
            // Construir units e adicionar às stacks da Squad e SubSquad.
            Unit unit1 = new Unit("Space Marine", new Vector2(1, 2), 100);
            squad.squadstack.Push(unit1);
            subsquad.subsquadstack.Push(unit1);
            Unit unit2 = new Unit("Space Marine", new Vector2(3, 4), 100);
            squad.squadstack.Push(unit2);
            subsquad.subsquadstack.Push(unit2);
            Unit unit3 = new Unit("Ripper", new Vector2(3, 4), 200);
            squad.squadstack.Push(unit3);
            Unit unit4 = new Unit("Healer", new Vector2(5, 6), 50);
            squad.squadstack.Push(unit4);
            //

            // Mostrar no ecrã a squad.
            Console.WriteLine("Squad: ");
            foreach (object item in squad.squadstack) {
                Console.WriteLine(item.ToString());
            }
            //

            // Adicionar movimento à squad.
            Console.WriteLine("New squad position: ");
            squad.Move(new Vector2(1, 1));
            foreach (object item in squad.squadstack) {
                Console.WriteLine(item.ToString());
            }
            //

            // Mostrar no ecrã a subsquad.
            Console.WriteLine("Sub squad: ");
            foreach (object item in subsquad.subsquadstack) {
                Console.WriteLine(item.ToString());
            }
            //

            // Adicionar movimento à subsquad.
            Console.WriteLine("New sub squad position: ");
            subsquad.Move(new Vector2(1, 1));
            foreach (object item in subsquad.subsquadstack) {
                Console.WriteLine(item.ToString());
            }
            //
        }
    }
    //
}

```

*Por [Francisco Pires](https://github.com/FRP7).*