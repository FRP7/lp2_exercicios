## Problema

12 - O teu jogo é _shooter_ de sucesso, e a classe base de todas as armas é
`Weapon`, cuja interface está definida da seguinte forma:

```cs
interface IWeapon
{
    // This property is true if weapon is in alternate firing mode, false
    // otherwise
    bool IsAlternate { get; }

    // Reload the weapon
    void Reload();

    // Shoot the weapon, return true if any rounds left to shoot in current
    // firing mode, false otherwise
    bool Shoot();

    // Switch between main and alternate firing modes
    void SwitchFireMode();
}
```

Os teus investidores exigem um DLC que inclua _melee weapons_, ou seja, armas
para combate corpo a corpo. Os investidores tomaram a liberdade de adquirir um
pacote de _assets_ para esse fim, e querem integra-lo no jogo. A interface das
_melee weapons_ é a seguinte:

```cs
interface IMelee
{
    // Attacks return true if they hit opponent
    bool AttackFromAbove();
    bool AttackFromBelow();
    bool AttackFromTheLeft();
    bool AttackFromTheRight();
}
```

Como podes resolver este problema? Escreve código para esse fim e justifica as
tuas opções.

## Soluções 

### Solução 1

De forma a seguir princípios *SOLID* (especificamente o *Open/Closed principle*)
, não devemos modificar a classe `Weapon` visto que esta já funciona 
perfeitamente, sem *bugs*. Também não podemos modificar a classe `Melee` nem a 
interface `IMelee` por esta mesma lógica.

O que é preciso fazer neste caso é implementar um **adaptador**, que faz com
que a interface `IMelee` fique compatível com a interface `IWeapon`, de acordo
com o *Adapter pattern*. O adaptador irá implementar a interface `IWeapon`, e 
terá como variável de instância uma instância duma classe que implementa a 
interface `IMelee`. 

O adaptador, então, quando implementa os métodos e
propriedades da interface `IWeapon`, irá utilizar componentes da variável de 
instância com `IMelee` de forma a 'encaixar' tais componentes na implementação
da outra interface, de forma que faça sentido. Isto é demonstrado neste código:

```cs
private class MeleeAdapter : IWeapon
{
    // Instance that is 'adapted'
    private IMelee meleeWeapon;

    // Cannot be read-only since it will be changed by SwitchFireMode().
    // This will delineate if the player can attack from left and right or
    // above and below
    public bool IsAlternate { get; private set; }

    // Does nothing-- you can't reload a melee weapon
    public void Reload()
    {

    }

    // This method will attack twice with the weapon, and the general direction
    // will be decided with the IsAlternate property. If both attacks miss, it
    // returns false, otherwise returns true.
    public bool Shoot()
    {
        if (IsAlternate)
        {
            if (!meleeWeapon.AttackFromTheLeft())
                if (!meleeWeapon.AttackFromTheRight()) return false;
            else return true;
        }
        else
        {
            if (!meleeWeapon.AttackFromAbove())
                if (!meleeWeapon.AttackFromBelow()) return false;
            else return true;
        }
    }

    // Negates itself in order to change the 'fire mode' (which in this case 
    // will only affect the directions in which the player can attack)
    public void SwitchFireMode()
    {
        IsAlternate = !IsAlternate;
    }

    // Constructor. Receives only the instance of a class that implements
    // IMelee.
    public MeleeAdapter(IMelee meleeWeapon)
    {
        this.meleeWeapon = meleeWeapon;
    }
}
```

O que foi feito no código acima foi uma adaptação dos quatro métodos declarados
na interface `IMelee` aos componentes da interface `IWeapon`. Essencialmente, 
o método `Shoot()` irá tratar de todos os ataques, que irão mudar dependendo do
*firing mode* (neste caso é apenas algo que irá alterar as direções, pois se 
trata de uma arma `melee`) gerido pela propriedade `IsAlternate`.

O jogador irá atacar duas vezes num mesmo `Shoot()`, cujas direções totais são
para a esquerda/direita (caso `IsAlternate` seja `true`), e de cima/baixo (caso
`IsAlternate` seja `false`).

O método que antigamente mudava o *firing mode* agora irá mudar se a arma 
`melee` irá atacar na horizontal ou na vertical com o `Shoot()`. E visto que 
não há motivos para uma arma `Melee` ter de recarregar, o método fica vazio.

*Por [Marco Domingos](https://github.com/condmaker)*


### Solução 2

A minha solução foi criar um adaptador (*Adapter Pattern*) para implementar o
código do `Melee` sem necessitar de mudar código na solução 
(se funciona, não se deve mexer). 
Durante a adaptação, tentei sempre que possível utilizar as *features* 
da `Weapons` de forma a tornar a `Melee` mais interessante, por exemplo, 
coloquei *stamina* que é gasto para realizar ataques e que para recuperar, 
tem que fazer *reload* (que pode ser chamado no comportamento de descanso, 
de acordo com o que o game designer achar melhor).

Classe `MeleeAdapter`
```cs
using System;

namespace _02_12
{
    /// <summary>
    /// Adaptador de Melee
    /// </summary>
    class MeleeAdapter : IWeapon
    {
        // Interface IMelee.
        private IMelee melee;

        // Enum dos tipos de ataque.
        private MeleeAttacks meleeAttacks;

        // Indicar se o jogador faz ataques horizontais ou verticais.
        public bool IsAlternate { get; }

        // Stamina necessária para realizar os ataques.
        private int stamina;

        // Recarregar a stamina.
        public void Reload() {
            stamina = 10;
        }

        /// <summary>
        /// Atacar caso tenha stamina suficiente.
        /// </summary>
        /// <returns> Retorna falso se não tiver stamina suficiente. </returns>
        public bool Shoot() {
            if(stamina >= 10) {
                if (meleeAttacks == MeleeAttacks.HorizontalAttack) {
                    melee.AttackFromTheLeft();
                    melee.AttackFromTheRight();
                    stamina -= 10;
                } else if (meleeAttacks == MeleeAttacks.VerticalAttack) {
                    melee.AttackFromAbove();
                    melee.AttackFromBelow();
                    stamina -= 10;
                }
                return true;
            } else {
                Console.WriteLine("Not enough stamina.");
                return false;
            }
        }

        // Mudar o tipo de ataque.
        public void SwitchFireMode() {
            if(IsAlternate == true) {
                meleeAttacks = MeleeAttacks.HorizontalAttack;
            }
            else {
                meleeAttacks = MeleeAttacks.VerticalAttack;
            }
        }

        // Inicializar o adaptador.
        public MeleeAdapter(IMelee melee, bool isAlternate) {
            stamina = 10;
            IsAlternate = isAlternate;
            this.melee = melee;
        }
    }
}
```

Foi acrescentado um `enum` à solução de forma a representar o tipo de ataques.

Enum `MeleeAttacks`
```cs
using System;

namespace _02_12
{
    enum MeleeAttacks
    {
        HorizontalAttack,
        VerticalAttack
    }
}
```


*Por [Francisco Pires](https://github.com/FRP7)*